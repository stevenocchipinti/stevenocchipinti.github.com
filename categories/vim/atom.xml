<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: vim | StevenOcchipinti.com]]></title>
  <link href="http://blog.stevenocchipinti.com/categories/vim/atom.xml" rel="self"/>
  <link href="http://blog.stevenocchipinti.com/"/>
  <updated>2013-07-22T23:20:19+10:00</updated>
  <id>http://blog.stevenocchipinti.com/</id>
  <author>
    <name><![CDATA[Steven Occhipinti]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Recursive search with vimgrep]]></title>
    <link href="http://blog.stevenocchipinti.com/2011/10/recursive-search-with-vimgrep.html"/>
    <updated>2011-10-12T02:46:00+11:00</updated>
    <id>http://blog.stevenocchipinti.com/2011/10/recursive-search-with-vimgrep</id>
    <content type="html"><![CDATA[<div class="css-full-post-content js-full-post-content">
Usually when I need to find things in multiple files, I would use <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">grep</span> or <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">ack</span> from a terminal and then open those files in vim to do whatever it is that I have to do.<br /><br />This is ok, but sometimes this can be a little annoying.<br />Vim has a <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">:grep</span> function which will use the system <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">grep</span> command, but it also has a <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">:vimgrep</span> function that is built in to vim.<br /><br />I had left a bunch of TODO's through out my code as a reminder to come back to them, so using <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">:vimgrep</span> I was able to quickly jump between them:<br /><br /><blockquote><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">:vimgrep TODO **/*</div></blockquote><br />This tells vim to search for the pattern "<span style="font-family: &quot;Courier New&quot;,Courier,monospace;">TODO</span>" recursively from the current directory.<br />The "<span style="font-family: &quot;Courier New&quot;,Courier,monospace;">**/</span>" means recursive and the "<span style="font-family: &quot;Courier New&quot;,Courier,monospace;">*</span>" means any file - therefore "<span style="font-family: &quot;Courier New&quot;,Courier,monospace;">**/*.rb</span>" would just search the ruby scripts.<br /><br />The results are loaded into the "quickfix window". This means if you want to see all the occurences, you can open the list with <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">:copen</span><br />Naturally, <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">:cnext</span>, <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">:cprevious</span>, <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">:cfirst</span>, <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">:clast</span>, etc. will allow you to jump between them or you can use the quicklist window and press enter on the filename, or in gvim you can even use the mouse.<br /><br />In addition, I use <a href="https://github.com/tpope/vim-unimpaired">Tim Pope's Unimpaired vim plugin</a>,which provides the easy shortcuts '<span style="font-family: &quot;Courier New&quot;,Courier,monospace;">[q</span>' and '<span style="font-family: &quot;Courier New&quot;,Courier,monospace;">]q</span>' for <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">:cprevious</span> and <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">:cnext</span> (respectively)
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Regex substitution 101]]></title>
    <link href="http://blog.stevenocchipinti.com/2011/08/regex-substitution-101.html"/>
    <updated>2011-08-01T07:42:00+10:00</updated>
    <id>http://blog.stevenocchipinti.com/2011/08/regex-substitution-101</id>
    <content type="html"><![CDATA[<div class="css-full-post-content js-full-post-content">
A while ago I was helping a friend with a regex.<br />He  wanted to extract parts of the <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">/etc/passwd</span> file, so I explained my basic thought process to him so he could understand how I came up with the pattern.<br />I thought I would (paraphrase and) blog this explanation, as it might just help others out too.<br /><br /><b>The Explanation:</b><br />First you have to write a regex that matches as much of the string (in this case the lines in the <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">passwd</span> file) as you need (or all of it to be safe):<br /><br /><blockquote><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">[^:]</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = will match a character that is not a colon</blockquote><br />You can repeat this pattern with the * operator to match everything up to the first colon (because that wont match the pattern):<br /><br /><blockquote><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">[^:]*</span>&nbsp;&nbsp;&nbsp;&nbsp; = will match everything up to the colon</blockquote><br />That pattern obviously doesnt have the bit you want, so you need to keep matching...<br />The next character you need to match is the colon itself:<br /><br /><blockquote><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">[^:]*:</span>&nbsp;&nbsp;&nbsp; = will match everything up to the colon, and then one colon character too</blockquote><br />This isn't enough either, but now you just need to repeat your self for as many sections as you want.<br />There is 6 colons and 7 fields in your example of the passwd file, so repeat the pattern to suit:<br /><br /><blockquote><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:[^:]*</div></blockquote><br />Now this pattern will match the entire string by going through section-by-section.<br />Of course .* would also match the whole string, but now we have parts of the pattern that represent parts of the string.<br />Using these parts, we can wrap the bit you want to use with backreferences (brackets) so we can use them later.<br /><br />Lets say you only wanted the 5th field (the username).<br />First, wrap the 5th field in a backreference.<br />Note you have to escape the brackets with a backslash otherwise it will look for an actual bracket character:<br /><br /><blockquote><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">[^:]*:[^:]*:[^:]*:[^:]*:\([^:]*\):[^:]*:[^:]*</div></blockquote><br />Now you can use it in a substitution, which will replace everything that is matched with what you tell it to:<br /><br /><blockquote><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">:%s/[^:]*:[^:]*:[^:]*:[^:]*:\([^:]*\):[^:]*:[^:]*/hello</div></blockquote><br />This will replace what it has matched (which is everything) with the word 'hello'<br />Now you can add that part that you captured earlier with the backreference<br /><br /><blockquote><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">:%s/[^:]*:[^:]*:[^:]*:[^:]*:\([^:]*\):[^:]*:[^:]*/hello \1</div></blockquote><br />The \1 means the first backreference, if you had 2 sets of backets, you could also use \2<br />Running this substition will result in this line:<br /><br /><blockquote><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">apache:x:48:48:Apache:/var/www:/sbin/nologin</div></blockquote><br />becoming this line:<br /><br /><blockquote><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">hello Apache</div></blockquote><br />To extend this further, you could add stuff like this:<br /><br /><blockquote><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">:%s/[^:]*:[^:]*:[^:]*:[^:]*:\([^:]*\):\([^:]*\):[^:]*/hello \1, I know you home is \2 because I know regex</div></blockquote><br />Which would result in this line:<br /><br /><blockquote><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">hello Apache, I know you home is /var/www because I know regex</div></blockquote><br />Obviously you wouldnt want to make these substitutions in your passwd file, but you could use this regex substitution in a pipeline with sed, like this:<br /><br /><blockquote><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">cat /etc/passwd | sed "s/[^:]*:[^:]*:[^:]*:[^:]*:\([^:]*\):\([^:]*\):[^:]*/hello \1, I know you home is \2 because I know regex/" &gt; ~/regexed.txt</div></blockquote><br />Note that unlike vim, sed requires the substitution to be terminated with a trailing separator, so valid syntaxes are:<br /><div style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></div><blockquote><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">sed =&nbsp; sed 's/PATTERN/REPLACEMENT/'</div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">vim =&nbsp; :s/PATTERN/REPLACEMENT/</div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">vim =&nbsp; :s/PATTERN/REPLACEMENT</div></blockquote><br />The last separator is useful for putting additional options, such as <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">g</span> for global replaces (multiple times on one line), etc.<br /><br />Another helpful note is that the separator does not have to be / it could be (almost) any character.<br />For example, / might be cumbersome if your dealing with paths that have a lot of /'s, so you could use # instead:<br /><blockquote><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">%s#this#that#g </span></blockquote>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vi mode for Bash]]></title>
    <link href="http://blog.stevenocchipinti.com/2011/06/vi-mode-for-bash.html"/>
    <updated>2011-06-26T23:22:00+10:00</updated>
    <id>http://blog.stevenocchipinti.com/2011/06/vi-mode-for-bash</id>
    <content type="html"><![CDATA[<div class="css-full-post-content js-full-post-content">
So it turns out bash has a vi mode!<br />(Can't believe I didn't know about this earlier)<br /><br />To enable vi mode, just type this into your shell:<br /><blockquote style="font-family: &quot;Courier New&quot;,Courier,monospace;">$&gt; set -o vi</blockquote><br />That will enable it for this shell so you can try it out, and if you like it, add that line to your <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">~/.bashrc</span> file for future.<br /><br />One really useful vi-mode command is pressing '<span style="font-family: &quot;Courier New&quot;,Courier,monospace;">v</span>' from command mode. This will put your current command line into vim to modify. <br /><br />To get more help on the commands available in vi-mode, take a look at the bottom of this man page:<br /><blockquote style="font-family: &quot;Courier New&quot;,Courier,monospace;">$&gt; man 3 readline</blockquote><br />To get more information on the various options available for bash, take a look at:<br /><blockquote><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">$&gt; help set</span></blockquote><br />I'm going to give it ago in the coming weeks to see if its actually useful or not. <br /><br />So far, I've found one small annoyance, I use ctrl+l to clear the terminal, but with the vi key bindings enabled, this only works from command mode (you have to hit <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">ESC</span> first).<br />To fix this, I added this to my <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">~/.bashrc</span> file:<br /><blockquote><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">bind -m vi-insert 'Control-l: clear-screen'</span></blockquote><br />These commands could also be added to <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">/etc/inputrc</span>, but I'm happy to leave these 2 lines together in my <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">~/.bashrc</span> so its easier to remember.
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Can't open file for writing]]></title>
    <link href="http://blog.stevenocchipinti.com/2011/06/cant-open-file-for-writing.html"/>
    <updated>2011-06-18T13:09:00+10:00</updated>
    <id>http://blog.stevenocchipinti.com/2011/06/cant-open-file-for-writing</id>
    <content type="html"><![CDATA[<p><blockquote><p>E212: Can&rsquo;t open file for writing<br/><br/>Press ENTER or type command to continue</p></blockquote></p>

<p>If you use <code>vim</code>, you have probably come across this error before.<br/>
It normally happens when you don&rsquo;t have permission to write to your chosen destination.</p>

<p>The temporary solution has traditionally been to save your changes to somewhere where you do have permissions (such as <code>/tmp</code> or <code>~</code>), then use <code>sudo</code> to <code>cp</code> it across, or re-open the file in vim with <code>sudo</code>.</p>

<p>A collegue at work showed me a great trick to get around this when it happens (Thanks <a href="https://twitter.com/rich0H">@rich0H</a>). All you have to do is add this to your <code>.vimrc</code> file:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>.vimrc </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>command! W w !sudo tee % &gt; /dev/null</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Then when you come across this error again, instead of of using <code>:w</code> you can use <code>:W</code> and it will prompt you for your <code>sudo</code> password before saving.</p>

<p>Works brilliantly!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Search and replace in multiple files with Vim]]></title>
    <link href="http://blog.stevenocchipinti.com/2011/05/search-and-replace-in-multiple-files.html"/>
    <updated>2011-05-30T09:11:00+10:00</updated>
    <id>http://blog.stevenocchipinti.com/2011/05/search-and-replace-in-multiple-files</id>
    <content type="html"><![CDATA[<div class="css-full-post-content js-full-post-content">
There are plenty of ways of doing a search and replace in multiple files in linux, but this is how I do it with vim.<br /><blockquote style="font-family: &quot;Courier New&quot;,Courier,monospace;">$&gt; vim firstfile secondfile theothers*<br />:all<br />:windo %s/this/that/g</blockquote><br />The <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">:all</span> will split the window to show you all the files at once.<br />This would not be the best option for lots of files, but for a small number you get to see the changes that are made. <br />The <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">:windo</span> will execute the given command for all the files in the current window.<br />Note this wont affect windows in other tabs.<br /><br />If you want to undo that change in all buffers, you can use the same method:<br /><blockquote><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">:windo undo</span></blockquote>When your finished, you can save and quit with:<br /><blockquote><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">:wqall</span></blockquote>There are plenty of variations, for more infomation checkout the help pages for these:<br /><blockquote><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">:tabdo</div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">:bufdo</div><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">:argdo</span></blockquote>
</div>

]]></content>
  </entry>
  
</feed>
