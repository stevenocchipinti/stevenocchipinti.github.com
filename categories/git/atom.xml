<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Git | Steven Occhipinti]]></title>
  <link href="http://blog.stevenocchipinti.com/categories/git/atom.xml" rel="self"/>
  <link href="http://blog.stevenocchipinti.com/"/>
  <updated>2016-12-28T02:20:32+11:00</updated>
  <id>http://blog.stevenocchipinti.com/</id>
  <author>
    <name><![CDATA[Steven Occhipinti]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rewriting Author and Email in Every Commit]]></title>
    <link href="http://blog.stevenocchipinti.com/2015/06/01/rewriting-author-and-email-in-every-commit/"/>
    <updated>2015-06-01T00:08:00+10:00</updated>
    <id>http://blog.stevenocchipinti.com/2015/06/01/rewriting-author-and-email-in-every-commit</id>
    <content type="html"><![CDATA[<p>Following on from a previous post about <a href="http://blog.stevenocchipinti.com/2015/04/30/rewriting-indentation-in-every-file-and-every-commit/">rewriting indentation for an entire git repo</a>,
another reason to rewrite the history of a whole repo is to change the email
address or name mentioned in commits.</p>

<p>Once again, be aware that rewriting history will cause problems if other people
have clones of the repo so make sure you understand the risks before doing
this!</p>

<p>To change the author name and email address for every commit, you can run this:</p>

<pre><code class="bash">git filter-branch -f --env-filter "
  GIT_AUTHOR_NAME='YOUR_NAME'
  GIT_AUTHOR_EMAIL='YOUR_EMAIL'
  GIT_COMMITTER_NAME='YOUR_NAME'
  GIT_COMMITTER_EMAIL='YOUR_EMAIL'
" HEAD
</code></pre>

<p>This will blindly replace all the commits with the details given, but if other
people have contributed, you may need to be a bit more careful and only replace
your own:</p>

<pre><code class="bash">git filter-branch --commit-filter "
  if [ "$GIT_COMMITTER_NAME" = 'YOUR_ORIGINAL_NAME'];
  then
    GIT_AUTHOR_NAME='YOUR_NEW_NAME'
    GIT_AUTHOR_EMAIL='YOUR_NEW_EMAIL'
    GIT_COMMITTER_NAME='YOUR_NEW_NAME'
    GIT_COMMITTER_EMAIL='YOUR_NEW_EMAIL'
    git commit-tree "$@";
  else
    git commit-tree "$@";
  fi
" HEAD
</code></pre>

<p>If you understand the risks of rewriting history for a shared repository, you
can force push with the <code>-f</code> flag:</p>

<pre><code>git push -f
</code></pre>

<p>Then, to ensure future commits don&rsquo;t use the wrong name and email, you can set
it explicity for this particular repo (instead of globally) with these
commands:</p>

<pre><code>git config user.email "your_email@example.com"
git config user.email "your_email@example.com"
</code></pre>

<p>Keep in mind this will only work for this particular clone as the details will
be stored locally in <code>.git/config</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rewriting Indentation in Every File and Every Commit]]></title>
    <link href="http://blog.stevenocchipinti.com/2015/04/30/rewriting-indentation-in-every-file-and-every-commit/"/>
    <updated>2015-04-30T21:51:00+10:00</updated>
    <id>http://blog.stevenocchipinti.com/2015/04/30/rewriting-indentation-in-every-file-and-every-commit</id>
    <content type="html"><![CDATA[<p>It seems the JavaScript community is divided into two camps when it comes to
indentation conventions: two spaces or four?</p>

<p>I personally prefer two spaces mainly because its what I&rsquo;m used to in Ruby, I
find it easier on the eyes and just that little bit easier to keep my lines
under 80 characters long (yes, I still think this is good practice).</p>

<p>Our team had come to a general consensus for using two spaces, but when we were
starting a new project based on an existing project that used four spaces, we
thought it would be nice to fix all the whitespace in one go.</p>

<p>In a rush, we made a commit that literally replaced all the whitespace with the
following command:</p>

<pre><code class="bash">find . -type f -exec sed -i "" "s/    /  /g" {} \;
</code></pre>

<p>The problem with this approach is that it makes going through commit messages
harder. It means that when you use <code>git annotate</code>, every line with indentation
is going to have the whitespace fix as the last commit, so then you would have
to jump back another commit to get the actual commit message for that line,
which can be fairly annoying.</p>

<p>Luckily, if you are forking an existing repository for a new project you have
the luxury of being able to rewrite history without causing any pain to others
as no one else would have checked it out yet.</p>

<p>Git provides a powerful command called <code>filter-branch</code>. It is designed to
rewrite large amounts of history in one go. This can be useful to purge
sensitive information from every commit or update an email address in the
commit data, etc. The only problem with this is, just like rebasing, any
existing checkouts will not be able to simply use <code>git pull</code> cleanly after the
history has been rewritten upstream, but this isn&rsquo;t a problem for new projects.</p>

<p>In order to execute the command above for every commit in our repo, we can make
use of the <code>--tree-filter</code> option like this:</p>

<pre><code class="bash">git filter-branch --tree-filter 'find . -type f -exec sed -i "" "s/    /  /g" {} \;' HEAD
</code></pre>

<p>Please note, this can take quite some time, especially for large repositories.
You should also make sure there are no files that specifically need four spaces
(like markdown files, etc.), otherwise you may want to restrict the <code>find</code>
command to only effect files you know are safe to change (<code>*.js</code> for example).</p>

<p>For more information on rewriting history and <code>git filter-branch</code>, see this
<a href="https://git-scm.herokuapp.com/book/en/v2/Git-Tools-Rewriting-History#The-Nuclear-Option:-filter-branch">article</a>
and the
<a href="https://git-scm.herokuapp.com/docs/git-filter-branch">documentation</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git Reset Cheatsheet]]></title>
    <link href="http://blog.stevenocchipinti.com/2015/03/24/git-reset-cheatsheet/"/>
    <updated>2015-03-24T11:13:00+11:00</updated>
    <id>http://blog.stevenocchipinti.com/2015/03/24/git-reset-cheatsheet</id>
    <content type="html"><![CDATA[<p>The <code>reset</code> command in git does quite a lot, but I always forget all its uses.<br/>
This is a cheatsheet based on <a href="http://git-scm.com/blog/2011/07/11/reset.html">this blog</a>.</p>

<p>The <code>reset</code> command will:<br/>
1. Move whatever branch <code>HEAD</code> points to <em>(stop here unless <code>--soft</code>)</em><br/>
2. THEN, make the Index look like that <em>(stop here unless <code>--hard</code>)</em><br/>
3. THEN, make the Working Directory look like that</p>

<h2>Commit level</h2>

<table>
<thead>
<tr>
<th>                            </th>
<th> Updates Current Branch? </th>
<th> Updates Index? </th>
<th> Updates Working Dir? </th>
<th> Working Dir Safe?                               </th>
</tr>
</thead>
<tbody>
<tr>
<td> <code>reset --soft [commit]</code>    </td>
<td> YES                     </td>
<td> NO             </td>
<td> NO                   </td>
<td> YES                                             </td>
</tr>
<tr>
<td> <code>reset (--mixed) [commit]</code> </td>
<td> YES                     </td>
<td> YES            </td>
<td> NO                   </td>
<td> YES                                             </td>
</tr>
<tr>
<td> <code>reset --hard [commit]</code>    </td>
<td> YES                     </td>
<td> YES            </td>
<td> YES                  </td>
<td> <span style="color: rgb(255, 38, 0);">NO</span> </td>
</tr>
<tr>
<td> <code>checkout [commit]</code>        </td>
<td> NO                      </td>
<td> YES            </td>
<td> YES                  </td>
<td> YES                                             </td>
</tr>
</tbody>
</table>


<p><strong>reset &#45;&#45;soft [commit]</strong><br/>
When given <code>HEAD~</code>, this undos the git commit<br/>
Will move the current branch back to the given commit, but not update the index or working directory<br/>
This provides similar functionality as <code>git checkout --amend</code> (but changing the whole commit, not just the message)</p>

<p><strong>reset (&#45;&#45;mixed) [commit] <span style="color: rgb(160, 160, 160); font-weight: normal;">(default form)</span></strong><br/>
When given <code>HEAD~</code>, this undos the <code>git commit</code> and the <code>git add</code><br/>
Will move the current branch and update the index, but working directory will remain untouched</p>

<p><strong>reset &#45;&#45;hard [commit] <span style="color: rgb(255, 38, 0);">(unsafe)</span></strong><br/>
When given <code>HEAD~</code>, this undos the <code>git commit</code>, <code>git add</code> and also the changes in the working directory<br/>
Will update all three trees to match the given commit<br/>
This is useful to remove commits you donâ€™t want<br/>
From a clean working tree, it is also useful to undo a conflicted (or not conflicted) <code>git merge</code> or a <code>git pull</code><br/>
From a dirty working tree, use <code>--merge</code> instead, this will safely preserve your local changes<br/>
The <code>--keep</code> option is useful when removing some of the last commits while safely keeping your local changes</p>

<p><strong>checkout [commit]</strong><br/>
When given <code>HEAD~</code>, this will safely update the working directory and the index without moving the current branch<br/>
This will leave you in a <em>detached HEAD</em> state</p>

<h2>File level</h2>

<table>
<thead>
<tr>
<th>                            </th>
<th> Updates Current Branch? </th>
<th> Updates Index? </th>
<th> Updates Working Dir? </th>
<th> Working Dir safe?                               </th>
</tr>
</thead>
<tbody>
<tr>
<td> <code>reset (commit) [file]</code>    </td>
<td> NO                      </td>
<td> YES            </td>
<td> NO                   </td>
<td> YES                                             </td>
</tr>
<tr>
<td> <code>checkout (commit) [file]</code> </td>
<td> NO                      </td>
<td> NO             </td>
<td> YES                  </td>
<td> <span style="color: rgb(255, 38, 0);">NO</span> </td>
</tr>
</tbody>
</table>


<p><strong>reset (commit) [file]</strong><br/>
When given a file path, the first step of updating the branch that <code>HEAD</code> points to is skipped<br/>
Will update the index only to match commit, leaving both working directory and current branch untouched<br/>
From here, you could use <code>git checkout</code> to make the working directory match the index, although <code>git checkout</code> can do that with one command (see below)<br/>
The commit parameter will default to <code>HEAD</code> which effectively <em>un-stages</em> files</p>

<p><strong>checkout (commit) [file] <span style="color: rgb(255, 38, 0);">(unsafe)</span></strong><br/>
Updates the working directory only, without changing the index, current branch or even what <code>HEAD</code> is pointing to<br/>
This would effectively be <code>git reset --hard [branch] file</code>, but this command does not exist</p>

<p>More info and examples in <code>git reset --help</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Completely Removing a Git Commit Due to Sensitive Information]]></title>
    <link href="http://blog.stevenocchipinti.com/2014/03/10/completely-removing-a-git-commit-due-to-sensitive-information/"/>
    <updated>2014-03-10T15:07:00+11:00</updated>
    <id>http://blog.stevenocchipinti.com/2014/03/10/completely-removing-a-git-commit-due-to-sensitive-information</id>
    <content type="html"><![CDATA[<p>I recently made a big mistake and checked in some sensitive information into a
public GitHub repository.</p>

<p>The first reaction is to remove that sensitive information. While that is a good
first step, making a new commit to remove the information means that when anyone
looks at the commit history, the sensitive information will still be visible.</p>

<h2>Re-writing history</h2>

<p>The next step is to re-write the git history.<br/>
This can be done a few ways, but I took a simple approach and sqaushed the
commits down such that the addition and removal of the sensitive information
cancel each other out and the new commit doesn&rsquo;t contain any sensitive
information.</p>

<p>To demonstrate, here is the history of a git respository where some sensitive
information was commited in <code>bbd80c4</code> and then removed in <code>a120437</code>.</p>

<pre><code>$&gt; git log --oneline
a120437 Ooops... remove sensitive data!
bbd80c4 Add some more data
0115d7b Add some data
20133f4 Initial commit

$&gt; git show bbd80c4
diff --git a/data b/data
index f8327c3..afbbccd 100644
--- a/data
+++ b/data
@@ -1 +1,3 @@
 KEY=value
+MORE=data
+PASSWORD=secret

$&gt; git show a120437
diff --git a/data b/data
index afbbccd..1f0aa11 100644
--- a/data
+++ b/data
@@ -1,3 +1,2 @@
 KEY=value
 MORE=data
-PASSWORD=secret
</code></pre>

<p>From here, I used git&rsquo;s interactive rebase feature to modify the relevant
commits. In this case, I chose the commit just before the sensitive data was
added, like this: <code>git rebase -i 0115d7b</code></p>

<p>In the interactive editor, I did the following and then provided a new commit
message:</p>

<pre><code>pick a120437 Ooops... remove sensitive data!
squash bbd80c4 Add some more data
</code></pre>

<p>This resulted in the last 2 commits being merged into a new one.<br/>
Here is the history:</p>

<pre><code>$&gt; git log --oneline
fd04bfc Add some more data
0115d7b Add some data
20133f4 Initial commit

$&gt; git show fd04bfc
diff --git a/data b/data
index f8327c3..1f0aa11 100644
--- a/data
+++ b/data
@@ -1 +1,2 @@
 KEY=value
+MORE=data
</code></pre>

<p>Rewriting commits that have already been pushed to a remote means a couple of
things.<br/>
For one, when you push this new history to the remote, you may require
the <code>--force</code> option to disregard the existing history.<br/>
Also, anyone who has an existing clone of the repository will have issues when
they pull down the latest changes but in the case of sensitive information, this
is a necessary side-effect.</p>

<h2>Cleaning up the cached commits</h2>

<p>We&rsquo;re not done yet!<br/>
Git keeps track of all changes made to a repository, even though the history
does not show the <em>bad</em> commits, they are still there! You can view all changes
to the repository using <code>git reflog</code>. From this command you can find the SHA of
the <em>bad</em> commit and then use <code>git show</code> to see the sensitive information.</p>

<p>This means that GitHub also still has the <em>bad</em> commits and if you know the SHA
you will be able to find that sensitive information again.
To fix this we should clear the local cache and GitHub&rsquo;s cache.</p>

<p>You can clear the your local reflog by issuing these commands:
<code>
rm -rf .git/refs/original/
git reflog expire --expire=now --all
git gc --prune=now
git gc --aggressive --prune=now
</code></p>

<p>GitHub doesn&rsquo;t give us a way to clear a repositorys cache, but due to the
nature of git, simply deleting the repository and pushing a new copy of your
local repository to GitHub will effectively destroy that cache.</p>

<p>GitHub also have an article on how to <a href="https://help.github.com/articles/remove-sensitive-data">remove sensitive data</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git + Hub = GitHub]]></title>
    <link href="http://blog.stevenocchipinti.com/2012/02/git-hub-github.html"/>
    <updated>2012-02-20T02:37:00+11:00</updated>
    <id>http://blog.stevenocchipinti.com/2012/02/git-hub-github</id>
    <content type="html"><![CDATA[<div class="css-full-post-content js-full-post-content">
As mentioned in a <a href="http://blog.stevenocchipinti.com/2011/09/code-review-workflow-with-github.html" target="_blank">previous post</a>, we use <a href="http://scottchacon.com/2011/08/31/github-flow.html" target="_blank">GitHub-Flow</a> at work and I really like it.<br />In essence, it involves doing work in feature branches, while maintaining an <i>always deployable</i> <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">master</span> branch, then opening a pull request to merge a new feature / bugfix into <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">master</span>, which provides a great mechanism for code review / sign-off.<br /><br />So a fairly typical situation would be as follows:<br /><ul><li>Bug found in app</li><li>Create an issue on GitHub with description, assignee, etc.</li><li>Create a new branch off master for the fix</li><li>Code it up, test locally, etc.</li><li>Push branch to GitHub </li><li>Open pull request to merge back into master</li><li>Get review / sign-off inside of the pull request</li><li>Deploy </li></ul>When a pull request is opened on GitHub, it automatically creates an issue for that pull request, which would normally be helpful, but we already created an issue when the bug was discovered.<br />So now we have 2 issues and 1 pull request. What's nice is that if I push more commits to that branch, it will appear in the pull request automatically, but not the initial issue.<br /><br />After looking into this, it seems (AFAIK) GitHub do not provide a way of attaching a pull request to an existing issue via the site, but they do provide that functionality via their API.<br /><br />That is when I discovered <a href="http://defunkt.io/hub/" target="_blank"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Hub</span></a>.<br /><a href="https://github.com/defunkt/hub" target="_blank"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Hub</span></a> is a wrapper for <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">git</span> and while it adds more power to alot of the standard git commands, hub adds one command that is really useful for me:<br /><br /><blockquote class="tr_bq" style="font-family: &quot;Courier New&quot;,Courier,monospace;">git pull-request -i 49</blockquote><br />This basically means<i> "Open a pull request to merge the current branch into master and attach the pull request to issue 49"</i>.<br /><br />This means that the initial bug description, the commits, the review conversation and the merge are all encapsulated in a single issue - fantastic!<br />I don't know why this isn't built in to the web interface (or maybe it is and I just don't know how).
</div>

]]></content>
  </entry>
  
</feed>
